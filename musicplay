-- Detecta o jogador
local Players = game:GetService("Players")
local player = Players.LocalPlayer

-- Lista de nicks permitidos
local whitelist = {
    ["roblox"] = true,
    ["RIAN_ytb01"] = true,
}

-- Verifica o nick
if not whitelist[player.Name] then
    player:Kick("NOT WHITELISTED")
    return -- Impede o script de continuar
end

-- Inicialização do Rayfield UI
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
    Name = "Reach",
    LoadingTitle = "Loading 89/100",
    LoadingSubtitle = "100/100 Finishing...",
    ConfigurationSaving = {
       Enabled = true,
       FolderName = nil,
       FileName = "trojan"
    },
    Discord = {
       Enabled = true,
       Invite = "discord.gg/1231241f",
       RememberJoins = true
    },
    KeySystem = true,
    KeySettings = {
       Title = "Key System",
       Subtitle = "Put the key",
       Note = "are you a buyer?",
       FileName = "trojan2",
       SaveKey = false,
       GrabKeyFromSite = false,
       Key = {"UNTITLED"}
    }
})

-- Criação da aba "Reach"
local ReachTab = Window:CreateTab("Reach", 4483362458)

-- Tabela para armazenar os valores de alcance para cada parte do corpo
local reachValues = {
    ["Head"] = 1,
    ["Right Leg"] = 1,
    ["Left Leg"] = 1,
    ["Right Arm"] = 1,
    ["Left Arm"] = 1,
    ["Torso"] = 1
}

-- Função para criar sliders para cada parte do corpo
for partName, defaultValue in pairs(reachValues) do
    ReachTab:CreateSlider({
        Name = "Reach - " .. partName,
        Range = {1, 99},
        Increment = 1,
        Suffix = " studs",
        CurrentValue = defaultValue,
        Flag = "Reach_" .. partName,
        Callback = function(Value)
            reachValues[partName] = Value
        end,
    })
end

-- Função para atualizar a lista de objetos interativos (bolas)
local balls = {}
local lastRefreshTime = os.time()
function refreshBalls(force)
    if not force and (lastRefreshTime + 2 > os.time()) then
        print("Atualização muito recente")
        return
    end
    lastRefreshTime = os.time()
    table.clear(balls)
    for _, v in pairs(workspace:GetDescendants()) do
        if v.Name == "TPS" or v.Name == "ESA" or v.Name == "MRS" or v.Name == "SSS" or v.Name == "PRS" or v.Name == "MPS" or v.Name == "AIFA" or v.Name == "RBZ" then
            task.wait()
            table.insert(balls, v)
        end
    end
end

-- Inicializa a lista de bolas
refreshBalls(true)

-- Criação da aba "Visualizer"
local VisualizerTab = Window:CreateTab("Visualizer", 4483362458)

-- Variável para ativar/desativar visualizador
local visualizerEnabled = true

-- Tabela para armazenar quais partes estão ativas no cálculo
local activeParts = {
    ["Head"] = true,
    ["Right Leg"] = true,
    ["Left Leg"] = true,
    ["Right Arm"] = true,
    ["Left Arm"] = true,
    ["Torso"] = true
}

-- Função para criar toggles para cada parte do corpo
for partName, _ in pairs(activeParts) do
    VisualizerTab:CreateToggle({
        Name = "Incluir " .. partName,
        CurrentValue = true,
        Flag = "Include_" .. partName,
        Callback = function(Value)
            activeParts[partName] = Value
        end,
    })
end

-- Função para criar a bola visualizadora
local function createVisualizerBall()
    local ball = Instance.new("Part")
    ball.Size = Vector3.new(1, 1, 1)
    ball.Shape = Enum.PartType.Ball
    ball.Material = Enum.Material.ForceField
    ball.Anchored = true
    ball.CanCollide = false
    ball.Transparency = 0.8
    ball.Color = Color3.fromRGB(255, 255, 255)
    ball.Name = "VisualizerBall"
    ball.Parent = workspace
    return ball
end

local visualizerBall = createVisualizerBall()

-- Atualiza posição da bola visualizadora constantemente
local RunService = game:GetService("RunService")
RunService.Heartbeat:Connect(function()
    if visualizerEnabled and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local totalReach = 0
        local partCount = 0
        for partName, reach in pairs(reachValues) do
            if activeParts[partName] then
                totalReach = totalReach + reach
                partCount = partCount + 1
            end
        end
        local averageReach = partCount > 0 and (totalReach / partCount) or 0
        local root = player.Character:FindFirstChild("HumanoidRootPart")
        if root then
            visualizerBall.Position = root.Position
            visualizerBall.Size = Vector3.new(averageReach * 2, averageReach * 2, averageReach * 2)
        end
    end
end)

-- Toggle para ativar/desativar visualizador
VisualizerTab:CreateToggle({
    Name = "Ativar Visualizer",
    CurrentValue = true,
    Flag = "VisualizerToggle",
    Callback = function(Value)
        visualizerEnabled = Value
        visualizerBall.Transparency = Value and Rayfield.Flags["BallTransparency"].CurrentValue or 1
    end,
})

-- Color Picker RGB (hex) para mudar cor da bola
VisualizerTab:CreateColorPicker({
    Name = "Cor da Bola",
    Color = Color3.fromRGB(255, 255, 255),
    Flag = "BallColor",
    Callback = function(color)
        visualizerBall.Color = color
    end,
})

-- Slider para mudar a transparência da bola
VisualizerTab:CreateSlider({
    Name = "Transparência da Bola",
    Range = {0, 1},
    Increment = 0.01,
    Suffix = "",
    CurrentValue = 0.8,
    Flag = "BallTransparency",
    Callback = function(Value)
        if visualizerEnabled then
            visualizerBall.Transparency = Value
        end
    end,
})

-- Conexão com o serviço de entrada do usuário
local UserInputService = game:GetService("UserInputService")
local player = game:GetService("Players").LocalPlayer

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end

    -- Atualiza a lista de bolas
    refreshBalls(false)

    -- Itera sobre cada parte do corpo configurada
    for partName, reach in pairs(reachValues) do
        local bodyPart = player.Character:FindFirstChild(partName)
        if bodyPart then
            for _, descendant in pairs(bodyPart:GetDescendants()) do
                if descendant.Name == "TouchInterest" and descendant.Parent then
                    for _, ball in pairs(balls) do
                        if (ball.Position - bodyPart.Position).Magnitude < reach then
                            firetouchinterest(ball, descendant.Parent, 0)
                            firetouchinterest(ball, descendant.Parent, 1)
                            break
                        end
                    end
                end
            end
        end
    end
end)
